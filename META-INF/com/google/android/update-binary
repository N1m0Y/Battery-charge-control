#!/sbin/sh

# Detect whether in boot mode
ps | grep zygote | grep -v grep >/dev/null && BOOTMODE=true || BOOTMODE=false

# Default permissions
umask 022

##########################################################################################
# Functions
##########################################################################################

ui_print() {
  if $BOOTMODE; then
    echo "$1"
  else 
    echo -n -e "ui_print $1\n" >> /proc/self/fd/$OUTFD
    echo -n -e "ui_print\n" >> /proc/self/fd/$OUTFD
  fi
}

grep_prop() {
  REGEX="s/^$1=//p"
  shift
  FILES=$@
  if [ -z "$FILES" ]; then
    FILES='/system/build.prop'
  fi
  cat $FILES 2>/dev/null | sed -n "$REGEX" | head -n 1
}

is_mounted() {
  if [ ! -z "$2" ]; then
    cat /proc/mounts | grep $1 | grep $2, >/dev/null
  else
    cat /proc/mounts | grep $1 >/dev/null
  fi
  return $?
}

mount_image() {
  if [ ! -d "$2" ]; then
    mount -o rw,remount rootfs /
    mkdir -p $2 2>/dev/null
    ($BOOTMODE) && mount -o ro,remount rootfs /
    [ ! -d "$2" ] && return 1
  fi
  if (! is_mounted $2); then
    LOOPDEVICE=
    for LOOP in 0 1 2 3 4 5 6 7; do
      if (! is_mounted $2); then
        LOOPDEVICE=/dev/block/loop$LOOP
        if [ ! -f "$LOOPDEVICE" ]; then
          mknod $LOOPDEVICE b 7 $LOOP 2>/dev/null
        fi
        losetup $LOOPDEVICE $1
        if [ "$?" -eq "0" ]; then
          mount -t ext4 -o loop $LOOPDEVICE $2
          if (! is_mounted $2); then
            /system/bin/toolbox mount -t ext4 -o loop $LOOPDEVICE $2
          fi
          if (! is_mounted $2); then
            /system/bin/toybox mount -t ext4 -o loop $LOOPDEVICE $2
          fi
        fi
        if (is_mounted $2); then
          ui_print "- Mounting $1 to $2"
          break;
        fi
      fi
    done
  fi
}

set_perm() {
  if [ -f $1 ]; then
    chown $2:$3 $1 || exit 1
    chmod $4 $1 || exit 1
    if [ ! -z "$5" ]; then
      chcon $5 $1 2>/dev/null
    else
      chcon 'u:object_r:system_file:s0' $1 2>/dev/null
    fi
  fi
}

set_perm_recursive() {
  find $1 -type d 2>/dev/null | while read dir; do
    set_perm $dir $2 $3 $4 $6
  done
  find $1 -type f 2>/dev/null | while read file; do
    set_perm $file $2 $3 $5 $6
  done
}

mktouch() {
  mkdir -p ${1%/*}
  if [ -z "$2" ]; then
    touch $1
  else
    echo $2 > $1
  fi
  chmod 644 $1
}

request_size_check() {
  reqSizeM=`unzip -l "$1" 2>/dev/null | tail -n 1 | awk '{ print $1 }'`
  reqSizeM=$((reqSizeM / 1048576 + 1))
}

image_size_check() {
  e2fsck -yf $1
  curBlocks=`e2fsck -n $1 2>/dev/null | grep $1 | cut -d, -f3 | cut -d\  -f2`;
  curUsedM=`echo "$curBlocks" | cut -d/ -f1`
  curSizeM=`echo "$curBlocks" | cut -d/ -f1`
  curFreeM=$(((curSizeM - curUsedM) * 4 / 1024))
  curUsedM=$((curUsedM * 4 / 1024 + 1))
  curSizeM=$((curSizeM * 4 / 1024))
}

install_busybox() {
case $ABILONG in
  arm64*) arch=arm64;;
  arm*) arch=arm;;
  x86_64*) arch=x86_64;;
  x86*) arch=x86;;
  mips64*) arch=mips64;;
  mips*) arch=mips;;
  *) ui_print "! Unknown architecture: $ABILONG";
  ui_print "! Busybox has not been installed";
  ui_print " ";
esac;

if [ $arch ]; then
ui_print "- Using architecture: $arch";

suimg=$(ls /data/su.img || ls /cache/su.img || ls /data/magisk.img || ls /cache/magisk.img) 2>/dev/null;
mnt=/$(basename $suimg .img);
if [ "$suimg" ]; then
  test "$mnt" == "/magisk" && magisk=/busybox-ndk/system;
  test -d $mnt$magisk/xbin -o "$magisk" && target=$mnt$magisk/xbin || target=$mnt/bin;
else
  target=/system/xbin
fi;
[ "$1" == "system" ] && target=/system/xbin
ui_print "- Using path: $target";
mkdir -p $target;
cp -af $INSTALLER/busybox/busybox-$arch $target/busybox;
chown 0:0 "$target/busybox";
chmod 755 "$target/busybox";
if [ "$magisk" ]; then
  cp -f $INSTALLER/busybox/module.prop /magisk/busybox-ndk/;
  touch /magisk/busybox-ndk/auto_mount;
fi;

ui_print "- Cleaning...";
cleanup="$target";
if [ "$target" == "$mnt$magisk/xbin" -a -f "$mnt$magisk/bin/busybox" ]; then
  $target/busybox rm -f $mnt$magisk/bin/busybox;
  cleanup="$mnt$magisk/bin $target";
fi;
for dir in $cleanup; do
  cd $dir;
  for i in $(ls -al `find -type l` | $target/busybox awk '{ print $(NF-2) ":" $NF }'); do
    case $(echo $i | $target/busybox cut -d: -f2) in
      *busybox) list="$list $dir/$(echo $i | $target/busybox cut -d: -f1)";;
    esac;
  done;
done;
$target/busybox rm -f $list;

ui_print "- Creating symlinks...";
for applet in `$target/busybox --list`; do
  if [ "$target" == "$mnt$magisk/bin" ]; then
    sysbin="$(ls /system/bin)";
    case $sysbin in
      *$applet*) ;;
      *) $target/busybox ln -sf busybox $applet;;
    esac;
  else
    $target/busybox ln -sf busybox $applet;
  fi;
done;

ui_print "- Busybox has been successfully installed";
fi
}

##########################################################################################
# System Install Functions
##########################################################################################

set_file_prop() {
  [ -n "$3" ] && prop=$3 || prop=/system/build.prop
  if (grep -q "$1=" $prop); then
    sed -i "s/${1}=.*/${1}=${2}/g" $prop
  else
    echo "${1}=${2}" >> $prop
  fi
}

detect_initpath() {
  [ ! $INITPATH ] && {
    if [ -d /system/su.d ]; then
      INITPATH=/system/su.d
    elif [ -d /system/etc/init.d ];then
      INITPATH=/system/etc/init.d
    fi
  
    if [ ! $INITPATH ]; then
      [ -f /data/su.img ] && {
	    mount_image /data/su.img /su
	    if is_mounted /su; then
	      [ -d /su/su.d ] && INITPATH=/su/su.d
	    fi
	  }
    fi
  }
}

install_system() {
  # Detect path for scripts (see detect_initpath function)
  detect_initpath
  
  # Unzip files
  cd $INSTALLER
  unzip -o "$ZIP"
  
  if is_mounted /system; then
    ui_print "- Installing to /system"
	
	# Install busybox
	unzip -o "$ZIP" "busybox/*"
	ui_print " "
	ui_print "******************************"
	ui_print "- Installing Busybox"
	ui_print "- by osm0sis @xda-developers"
	ui_print "******************************"
	install_busybox system
	ui_print " "
	
	# Replace/Remove folders
	if [ -n $REPLACE ]; then
	  ui_print "- Removing files"
	  [ "$PERMANENTDELETE" == false ] && {
        for TARGET in $REPLACE; do
          mv $TARGET $TARGET.bak
        done
	  } || {
        for TARGET in $REPLACE; do
          rm -rf $TARGET
        done
	  }
	fi
    
	# Copy files in system folder to /system
	if $AUTOMOUNT; then
	  ui_print "- Copying files to /system"
	  cp -af system/* /system
	fi
	
	# Set properties
	if [ -z $BUILDPROP ]; then
	  if [ -n $INITPATH ]; then
	    if $PROPFILE; then
	      ui_print "- Setting property scripts"
	      echo "#!/system/bin/sh" > $INITPATH/${MODID}-prop.sh
		  echo "" >> $INITPATH/${MODID}-prop.sh
	      for i in $(grep "[a-zA-Z0-9]=[a-zA-Z0-9]" $INSTALLER/common/system.prop | sed 's/ /_/g'); do
	        [[ $(echo $i | grep "#_") ]] || echo "setprop ${i%%=*} ${i#*=}" >> $INITPATH/${MODID}-prop.sh
          done
	      echo "" >> $INITPATH/${MODID}-prop.sh
	      set_perm $INITPATH/${MODID}-prop.sh 0 0 0700 
	    fi
	  else  
	    ui_print "! No proper directory to put scripts (prop)"
	  fi
	elif $BUILDPROP; then
	  ui_print "- Setting properties directly in /system/build.prop"
	  for i in $(grep "[a-zA-Z0-9]=[a-zA-Z0-9]" $INSTALLER/common/system.prop | sed 's/ /_/g'); do
	    [[ $(echo $i | grep "#_") ]] || set_file_prop "${i%%=*}" "${i#*=}" /system/build.prop
      done	  
	fi
	
	# post-fs-data script to $INITPATH
	# post-fs-data and latestartservice scripts might be executed almost
	# at the same time.
	[ -n $INITPATH ] && {
	  if $POSTFSDATA; then
	    ui_print "- Copying post-fs-data script to $INITPATH"
	    cp -af $INSTALLER/common/post-fs-data.sh $INITPATH/${MODID}-1.sh
	    set_perm $INITPATH/${MODID}-1.sh 0 0 0700
	  fi
	} || ui_print "! No proper directory to put scripts (post-fs-data)"
	
	# latestartservice script to $INITPATH
	# post-fs-data and latestartservice scripts might be executed almost
	# at the same time.
	[ -n $INITPATH ] && {
	  if $LATESTARTSERVICE; then
	    ui_print "- Copying latestartservice script to $INITPATH"
	    cp -af $INSTALLER/common/service.sh $INITPATH/${MODID}-2.sh
	    set_perm $INITPATH/${MODID}-2.sh 0 0 0700
	  fi
	} || ui_print "! No proper directory to put scripts (service)"
	
	# Set permissions
	ui_print "- Setting permissions"
	set_permissions_system
	
	ui_print "- Done"
	umount /system
	umount /vendor 2>/dev/null
	true
	exit
  else
    ui_print "! System not mounted"
	exit 1
  fi
}

##########################################################################################
# Flashable update-binary preparation
##########################################################################################

OUTFD=$2
ZIP=$3

readlink /proc/$$/fd/$OUTFD 2>/dev/null | grep /tmp >/dev/null
if [ "$?" -eq "0" ]; then
  OUTFD=0

  for FD in `ls /proc/$$/fd`; do
    readlink /proc/$$/fd/$FD 2>/dev/null | grep pipe >/dev/null
    if [ "$?" -eq "0" ]; then
      ps | grep " 3 $FD " | grep -v grep >/dev/null
      if [ "$?" -eq "0" ]; then
        OUTFD=$FD
        break
      fi
    fi
  done
fi

if $BOOTMODE && ! is_mounted /magisk; then
  ui_print "! Magisk is not activated!... abort"
  exit 1
fi

# Fix SuperSU.....
$BOOTMODE && $BINDIR/sepolicy-inject --live "allow fsck * * *"

# This path should work in any cases
TMPDIR=/dev/tmp

MOUNTPATH=/magisk
IMGNAME=magisk.img

if $BOOTMODE; then
  MOUNTPATH=/dev/magisk_merge
  IMGNAME=magisk_merge.img
fi

mkdir -p $TMPDIR 2>/dev/null
cd $TMPDIR
unzip -o "$ZIP" config.sh

if [ ! -f "config.sh" ]; then
  ui_print "! Failed: Unable to extract zip file!"
  exit 1
fi

source config.sh
[ -f /dev/.config ] && {
  chmod 755 /dev/.config
  source /dev/.config
}

INSTALLER=$TMPDIR/$MODID
MODPATH=$MOUNTPATH/$MODID

mkdir -p $INSTALLER
cd $INSTALLER
unzip -o "$ZIP" "common/*" module.prop

[ -z $SYSTEMINSTALL ] && [ -z $MAGISKINSTALL ] && {
  MAGISKINSTALL=false
  SYSTEMINSTALL=false
  if [ -f /data/magisk.img ]; then
    MAGISKINSTALL=true
    PERM=ro
  else
    SYSTEMINSTALL=true
    PERM=rw
  fi
  ! $MAGISKINSTALL && ! $SYSTEMINSTALL && SYSTEMINSTALL=true && PERM=rw
}

if [ $MAGISKINSTALL ] && $MAGISKINSTALL && [ -z $SYSTEMINSTALL ]; then
  PERM=ro
  MAGISKINSTALL=true
  SYSTEMINSTALL=false
fi
if [ $SYSTEMINSTALL ] && [ -z $MAGISKINSTALL ] && $SYSTEMINSTALL; then
  PERM=rw
  MAGISKINSTALL=false
  SYSTEMINSTALL=true
fi

$MAGISKINSTALL && SYSTEMINSTALL=false
$SYSTEMINSTALL && MAGISKINSTALL=false
[ ! $PERM ] && PERM=rw

##########################################################################################
# Main
##########################################################################################

# Print mod name
print_modname

# Please leave this message in your flashable zip for credits :)
if $MAGISKINSTALL; then
  ui_print "******************************"
  ui_print "Powered by Magisk (@topjohnwu)"
  ui_print "******************************"
else
  ui_print "******************************"
  ui_print "System/Less Install  (@veez21)"
  ui_print "******************************"
fi

ui_print "- Mounting /system($PERM), /vendor($PERM), /data, /cache"
mount -o $PERM /system 2>/dev/null
mount -o $PERM /vendor 2>/dev/null
mount /data 2>/dev/null
mount /cache 2>/dev/null

if [ ! -f '/system/build.prop' ]; then
  ui_print "! Failed: /system could not be mounted!"
  exit 1
fi

API=`grep_prop ro.build.version.sdk`
ABI=`grep_prop ro.product.cpu.abi | cut -c-3`
ABI2=`grep_prop ro.product.cpu.abi2 | cut -c-3`
ABILONG=`grep_prop ro.product.cpu.abi`

ARCH=arm
IS64BIT=false
if [ "$ABI" = "x86" ]; then ARCH=x86; fi;
if [ "$ABI2" = "x86" ]; then ARCH=x86; fi;
if [ "$ABILONG" = "arm64-v8a" ]; then ARCH=arm64; IS64BIT=true; fi;
if [ "$ABILONG" = "x86_64" ]; then ARCH=x64; IS64BIT=true; fi;

# You can get the Android API version from $API, the CPU architecture from $ARCH
# Useful if you are creating Android version / platform dependent mods

if $SYSTEMINSTALL; then
  install_system
  exit $?
fi

if is_mounted /data; then
  IMG=/data/$IMGNAME
  if [ ! -f "/data/magisk.img" ]; then
    ui_print "! Magisk is not installed!"
	ui_print "- Resorting to System Install"
	install_system
	exit $?
  fi
else
  IMG=/cache/magisk.img
  ui_print " "
  ui_print "***********************************"
  ui_print "*      !! Data unavailible !!     *"
  ui_print "* Magisk detection is impossible  *"
  ui_print "* Installation will still proceed *"
  ui_print "*  But please make sure you have  *"
  ui_print "*        Magisk installed!!       *"
  ui_print "***********************************"
  ui_print " "
fi

request_size_check "$ZIP"

if [ -f "$IMG" ]; then
  ui_print "- $IMG detected!"
  image_size_check $IMG
  if [ "$reqSizeM" -gt "$curFreeM" ]; then
    SIZE=$(((reqSizeM + curUsedM) / 32 * 32 + 64))
    ui_print "- Resizing $IMG to ${SIZE}M..."
    resize2fs $IMG ${SIZE}M
  fi
else
  SIZE=$((reqSizeM / 32 * 32 + 64));
  ui_print "- Creating $IMG with size ${SIZE}M"
  make_ext4fs -l ${SIZE}M -a /magisk -S $INSTALLER/common/file_contexts_image $IMG
fi

mount_image $IMG $MOUNTPATH
if ! is_mounted $MOUNTPATH; then
  ui_print "! $IMG mount failed... abort"
  exit 1
fi

# Install busybox
unzip -o "$ZIP" "busybox/*"
ui_print " "
ui_print "******************************"
ui_print "- Installing Busybox"
ui_print "- by osm0sis @xda-developers"
ui_print "******************************"
install_busybox
ui_print " "

# Create mod paths
rm -rf $MODPATH 2>/dev/null
mkdir -p $MODPATH

# Copy files
ui_print "- Copying files"
unzip -o "$ZIP" "system/*" -d $MODPATH

# Handle replace folders
for TARGET in $REPLACE; do
  mktouch $MODPATH$TARGET/.replace
done

# Auto Mount
if $AUTOMOUNT; then
  mktouch $MODPATH/auto_mount
fi

# prop files
if $PROPFILE; then
  cp -af $INSTALLER/common/system.prop $MODPATH/system.prop
fi

# Module info
cp -af $INSTALLER/module.prop $MODPATH/module.prop
if $BOOTMODE; then
  # Update info for Magisk Manager
  mktouch /magisk/$MODID/update
  cp -af $INSTALLER/module.prop /magisk/$MODID/module.prop
fi

# post-fs-data mode scripts
if $POSTFSDATA; then
  cp -af $INSTALLER/common/post-fs-data.sh $MODPATH/post-fs-data.sh
fi

# service mode scripts
if $LATESTARTSERVICE; then
  cp -af $INSTALLER/common/service.sh $MODPATH/service.sh
fi

ui_print "- Setting permissions"
set_permissions

ui_print "- Unmounting partitions"

umount $MOUNTPATH
losetup -d $LOOPDEVICE
rmdir $MOUNTPATH

# Shrink the image if possible
image_size_check $IMG
NEWDATASIZE=$((curUsedM / 32 * 32 + 32))
if [ "$curSizeM" -gt "$NEWDATASIZE" ]; then
  ui_print "- Shrinking $IMG to ${NEWDATASIZE}M..."
  resize2fs $IMG ${NEWDATASIZE}M
fi

if ! $BOOTMODE; then
  umount /system
  umount /vendor 2>/dev/null
fi

ui_print "- Done"
exit 0
